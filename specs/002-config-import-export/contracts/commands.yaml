# Tauri Command Contracts: Configuration Import/Export
# Feature: 002-config-import-export
# Date: 2025-11-01

# This file defines the Tauri command signatures (Rust backend ↔ TypeScript frontend bridge)

commands:
  # ============================================================================
  # Import Configuration Command
  # ============================================================================
  - name: import_config
    description: |
      Opens native macOS file picker dialog for user to select an skhd
      configuration file. Loads and parses the selected file, updates the
      current configuration state, and returns the loaded ConfigFile.

      User Story: US1 - Import Configuration from Custom Location (P1)

    rust_signature: |
      #[tauri::command]
      async fn import_config(
          state: State<'_, ConfigState>
      ) -> Result<ConfigFile, String>

    parameters: []  # No parameters - file selection handled by dialog

    returns:
      success:
        type: ConfigFile
        description: |
          Complete configuration loaded from selected file, including:
          - current_file_path: Set to the selected file path
          - shortcuts: Parsed shortcuts from file
          - parse_errors: Any non-fatal parsing warnings
          - is_modified: false (freshly loaded)

      error:
        type: string
        description: |
          User-friendly error message for failures:
          - "Import cancelled" - User closed dialog without selecting
          - "Cannot access file..." - Permission denied
          - "Configuration file not found..." - File doesn't exist
          - "Invalid skhd configuration..." - Parse errors

    behavior:
      - Opens AsyncFileDialog with filters: ["skhdrc", "conf", "txt"]
      - Default directory: ~/.config/skhd/
      - On user selection: Parse file with existing parser
      - Validate syntax before accepting
      - Update ConfigState.config with new ConfigFile
      - Set current_file_path to selected path
      - Return ConfigFile to frontend

    side_effects:
      - Updates global ConfigState
      - Previous unsaved changes are lost (frontend should warn)

    performance:
      - File dialog: Native macOS (no latency)
      - Parse time: <100ms for typical configs (<1000 lines)
      - Total: <200ms for user-perceived operation

  # ============================================================================
  # Export Configuration Command
  # ============================================================================
  - name: export_config
    description: |
      Opens native macOS save file dialog for user to select export
      destination. Serializes current in-memory configuration to skhd text
      format, validates syntax, and writes to selected file atomically.

      User Story: US2 - Export Current Configuration (P2)

    rust_signature: |
      #[tauri::command]
      async fn export_config(
          state: State<'_, ConfigState>
      ) -> Result<String, String>

    parameters: []  # No parameters - file destination handled by dialog

    returns:
      success:
        type: string
        description: |
          Absolute path to the exported file for user confirmation.
          Example: "/Users/alice/Desktop/my-config.skhdrc"

      error:
        type: string
        description: |
          User-friendly error message for failures:
          - "Export cancelled" - User closed dialog
          - "Cannot write to directory..." - Permission denied
          - "Configuration validation failed..." - Internal state invalid
          - "File operation failed..." - I/O error during write

    behavior:
      - Get current ConfigFile from state
      - Serialize to skhd text format
      - Validate by re-parsing serialized text
      - Open AsyncFileDialog.save_file()
      - Default filename: "skhdrc" or current filename
      - On user selection: Write atomically (temp + rename)
      - Return exported file path
      - Does NOT change current_file_path (export is copy operation)

    side_effects:
      - Creates/overwrites file at user-selected path
      - No changes to ConfigState (export-only operation)

    performance:
      - Serialization: <10ms
      - Validation: <50ms
      - Write: <50ms
      - Total: <200ms

  # ============================================================================
  # Reload Configuration Command
  # ============================================================================
  - name: reload_config
    description: |
      Reloads configuration from the currently tracked file path
      (current_file_path). Discards all in-memory unsaved changes. Frontend
      should show confirmation dialog before calling if is_modified is true.

      User Story: US3 - Reload from Default Location (P1)

    rust_signature: |
      #[tauri::command]
      async fn reload_config(
          state: State<'_, ConfigState>
      ) -> Result<ConfigFile, String>

    parameters: []  # Reloads from current_file_path in state

    returns:
      success:
        type: ConfigFile
        description: |
          Freshly parsed configuration from current_file_path:
          - shortcuts: Re-parsed from disk
          - is_modified: false (clean state)
          - current_file_path: Unchanged (still same source)

      error:
        type: string
        description: |
          User-friendly error message for failures:
          - "Configuration file not found..." - File deleted externally
          - "Cannot access file..." - Permission changed
          - "Invalid skhd configuration..." - File corrupted externally

    behavior:
      - Read current_file_path from ConfigState
      - Re-parse file using existing load logic
      - Replace ConfigState.config with fresh parse
      - Set is_modified = false
      - Return new ConfigFile

    side_effects:
      - DESTRUCTIVE: Discards all unsaved in-memory changes
      - Updates global ConfigState

    performance:
      - Parse time: <100ms
      - State update: <10ms
      - Total: <150ms

# ============================================================================
# TypeScript Service Interface
# ============================================================================
typescript_service:
  file: src/services/tauri.ts

  functions:
    - name: importConfig
      signature: |
        export async function importConfig(): Promise<ConfigFile>

      implementation: |
        import { invoke } from '@tauri-apps/api/core';
        import type { ConfigFile } from '../types';

        export async function importConfig(): Promise<ConfigFile> {
          return invoke<ConfigFile>('import_config');
        }

      usage: |
        // In Svelte component
        async function handleImport() {
          try {
            const config = await importConfig();
            // Config state updated automatically by Tauri
            // UI reactivity will update display
          } catch (error) {
            if (error !== "Import cancelled") {
              showError(error);
            }
          }
        }

    - name: exportConfig
      signature: |
        export async function exportConfig(): Promise<string>

      implementation: |
        export async function exportConfig(): Promise<string> {
          return invoke<string>('export_config');
        }

      usage: |
        async function handleExport() {
          try {
            const exportedPath = await exportConfig();
            showSuccess(`Configuration exported to: ${exportedPath}`);
          } catch (error) {
            if (error !== "Export cancelled") {
              showError(error);
            }
          }
        }

    - name: reloadConfig
      signature: |
        export async function reloadConfig(): Promise<ConfigFile>

      implementation: |
        export async function reloadConfig(): Promise<ConfigFile> {
          return invoke<ConfigFile>('reload_config');
        }

      usage: |
        async function handleReload() {
          // Check for unsaved changes first
          if (config.is_modified) {
            const confirmed = await showConfirmDialog(
              'Discard unsaved changes?',
              'This will reload from disk and lose your current edits.'
            );
            if (!confirmed) return;
          }

          try {
            const reloadedConfig = await reloadConfig();
            // State updated, UI will refresh
          } catch (error) {
            showError(error);
          }
        }

# ============================================================================
# Error Handling Contract
# ============================================================================
error_handling:
  philosophy: |
    All errors are converted to user-friendly strings before crossing the
    Tauri bridge. Frontend displays errors in toast notifications or modals.
    "Cancelled" operations are not shown as errors to the user.

  error_display:
    location: Toast notification component
    duration: 5 seconds for errors, 3 seconds for success
    dismiss: User can click to dismiss early

  cancellation_handling: |
    When user cancels a file dialog, commands return error string "Import
    cancelled" or "Export cancelled". Frontend should NOT display these as
    errors - they are normal user actions.

# ============================================================================
# Testing Contracts
# ============================================================================
testing:
  unit_tests:
    - Import with valid file → Returns ConfigFile
    - Import with invalid syntax → Returns parse errors in ConfigFile
    - Import cancelled → Returns error "Import cancelled"
    - Export valid config → Creates file at path
    - Export with validation failure → Returns error
    - Reload when file exists → Returns fresh ConfigFile
    - Reload when file missing → Returns error

  integration_tests:
    - Import → Edit → Export → Import again → Verify round-trip
    - Import custom → Save → Reload → Verify unchanged
    - Reload with unsaved changes → Verify changes discarded

  manual_tests:
    - File dialog appears native on macOS
    - File filters work correctly
    - Permission errors show clear messages
    - Large files (1000+ lines) parse quickly
